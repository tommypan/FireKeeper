// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 1.1.0.
// **********************************************************************

#ifndef __CS_H_
#define __CS_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
using namespace std;


namespace ClientProto
{
    enum MSG_ID
    {
        Login = 0,
        Match = 1,
    };
    inline string etos(const MSG_ID & e)
    {
        switch(e)
        {
            case Login: return "Login";
            case Match: return "Match";
            default: return "";
        }
    }
    inline int stoe(const string & s, MSG_ID & e)
    {
        if(s == "Login")  { e=Login; return 0;}
        if(s == "Match")  { e=Match; return 0;}

        return -1;
    }

    enum Match_RSP_RET
    {
        SUCCESS = 0,
        ISMATCHING = 1,
        UNKONWERROR = 2,
    };
    inline string etos(const Match_RSP_RET & e)
    {
        switch(e)
        {
            case SUCCESS: return "SUCCESS";
            case ISMATCHING: return "ISMATCHING";
            case UNKONWERROR: return "UNKONWERROR";
            default: return "";
        }
    }
    inline int stoe(const string & s, Match_RSP_RET & e)
    {
        if(s == "SUCCESS")  { e=SUCCESS; return 0;}
        if(s == "ISMATCHING")  { e=ISMATCHING; return 0;}
        if(s == "UNKONWERROR")  { e=UNKONWERROR; return 0;}

        return -1;
    }

    struct PKG : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ClientProto.PKG";
        }
        static string MD5()
        {
            return "f666f5b5306009931634a52d7890819b";
        }
        PKG()
        :uid(0),pkgHead(0)
        {
        }
        void resetDefautlt()
        {
            uid = 0;
            pkgHead = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(uid, 0);
            _os.write(pkgHead, 1);
            _os.write(pkgBody, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(uid, 0, true);
            _is.read(pkgHead, 1, true);
            _is.read(pkgBody, 2, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(uid,"uid");
            _ds.display(pkgHead,"pkgHead");
            _ds.display(pkgBody,"pkgBody");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(uid, true);
            _ds.displaySimple(pkgHead, true);
            _ds.displaySimple(pkgBody, false);
            return _os;
        }
    public:
        tars::Int64 uid;
        tars::UInt32 pkgHead;
        vector<tars::Char> pkgBody;
    };
    inline bool operator==(const PKG&l, const PKG&r)
    {
        return l.uid == r.uid && l.pkgHead == r.pkgHead && l.pkgBody == r.pkgBody;
    }
    inline bool operator!=(const PKG&l, const PKG&r)
    {
        return !(l == r);
    }

    struct LoginReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ClientProto.LoginReq";
        }
        static string MD5()
        {
            return "28e84f1420ec22b8dabf431dc7650432";
        }
        LoginReq()
        :uid(0),pswd(""),isRegiester(0)
        {
        }
        void resetDefautlt()
        {
            uid = 0;
            pswd = "";
            isRegiester = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(uid, 0);
            _os.write(pswd, 1);
            _os.write(isRegiester, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(uid, 0, true);
            _is.read(pswd, 1, true);
            _is.read(isRegiester, 2, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(uid,"uid");
            _ds.display(pswd,"pswd");
            _ds.display(isRegiester,"isRegiester");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(uid, true);
            _ds.displaySimple(pswd, true);
            _ds.displaySimple(isRegiester, false);
            return _os;
        }
    public:
        tars::Int64 uid;
        std::string pswd;
        tars::Char isRegiester;
    };
    inline bool operator==(const LoginReq&l, const LoginReq&r)
    {
        return l.uid == r.uid && l.pswd == r.pswd && l.isRegiester == r.isRegiester;
    }
    inline bool operator!=(const LoginReq&l, const LoginReq&r)
    {
        return !(l == r);
    }

    struct PlayerData : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ClientProto.PlayerData";
        }
        static string MD5()
        {
            return "ddf0b1cb90c6ca6fbabd3fafca89d2a3";
        }
        PlayerData()
        :uid(0),nickName(""),gold(0),grade(0),resID(0)
        {
        }
        void resetDefautlt()
        {
            uid = 0;
            nickName = "";
            gold = 0;
            grade = 0;
            resID = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(uid, 0);
            _os.write(nickName, 1);
            _os.write(gold, 2);
            _os.write(grade, 3);
            _os.write(resID, 4);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(uid, 0, true);
            _is.read(nickName, 1, true);
            _is.read(gold, 2, true);
            _is.read(grade, 3, true);
            _is.read(resID, 4, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(uid,"uid");
            _ds.display(nickName,"nickName");
            _ds.display(gold,"gold");
            _ds.display(grade,"grade");
            _ds.display(resID,"resID");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(uid, true);
            _ds.displaySimple(nickName, true);
            _ds.displaySimple(gold, true);
            _ds.displaySimple(grade, true);
            _ds.displaySimple(resID, false);
            return _os;
        }
    public:
        tars::Int64 uid;
        std::string nickName;
        tars::Int64 gold;
        tars::Char grade;
        tars::UInt32 resID;
    };
    inline bool operator==(const PlayerData&l, const PlayerData&r)
    {
        return l.uid == r.uid && l.nickName == r.nickName && l.gold == r.gold && l.grade == r.grade && l.resID == r.resID;
    }
    inline bool operator!=(const PlayerData&l, const PlayerData&r)
    {
        return !(l == r);
    }

    struct LoginRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ClientProto.LoginRsp";
        }
        static string MD5()
        {
            return "7358c710466133ec7a3823ef6f1f77d9";
        }
        LoginRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(playerData, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(playerData, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(playerData,"playerData");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(playerData, false);
            return _os;
        }
    public:
        ClientProto::PlayerData playerData;
    };
    inline bool operator==(const LoginRsp&l, const LoginRsp&r)
    {
        return l.playerData == r.playerData;
    }
    inline bool operator!=(const LoginRsp&l, const LoginRsp&r)
    {
        return !(l == r);
    }

    struct MatchReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ClientProto.MatchReq";
        }
        static string MD5()
        {
            return "282dee69d7580ed43b374bb636595df2";
        }
        MatchReq()
        :uid(0)
        {
        }
        void resetDefautlt()
        {
            uid = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(uid, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(uid, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(uid,"uid");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(uid, false);
            return _os;
        }
    public:
        tars::Int64 uid;
    };
    inline bool operator==(const MatchReq&l, const MatchReq&r)
    {
        return l.uid == r.uid;
    }
    inline bool operator!=(const MatchReq&l, const MatchReq&r)
    {
        return !(l == r);
    }

    struct MatchRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ClientProto.MatchRsp";
        }
        static string MD5()
        {
            return "e2bfc9db908cab81765afdfffebaca5b";
        }
        MatchRsp()
        :ret(0)
        {
        }
        void resetDefautlt()
        {
            ret = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, false);
            return _os;
        }
    public:
        tars::UInt8 ret;
    };
    inline bool operator==(const MatchRsp&l, const MatchRsp&r)
    {
        return l.ret == r.ret;
    }
    inline bool operator!=(const MatchRsp&l, const MatchRsp&r)
    {
        return !(l == r);
    }

    struct MatchNtf : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ClientProto.MatchNtf";
        }
        static string MD5()
        {
            return "fe12b17f7a0d21a0575021457e3a3f3c";
        }
        MatchNtf()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(matchPlayerList, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(matchPlayerList, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(matchPlayerList,"matchPlayerList");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(matchPlayerList, false);
            return _os;
        }
    public:
        vector<ClientProto::PlayerData> matchPlayerList;
    };
    inline bool operator==(const MatchNtf&l, const MatchNtf&r)
    {
        return l.matchPlayerList == r.matchPlayerList;
    }
    inline bool operator!=(const MatchNtf&l, const MatchNtf&r)
    {
        return !(l == r);
    }


}



#endif
